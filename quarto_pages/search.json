[
  {
    "objectID": "telemetry/index.html",
    "href": "telemetry/index.html",
    "title": "Ivy",
    "section": "",
    "text": "We want to give Ivy‚Äôs users as much flexibility as possible when it comes to data collection. Therefore, there are five different data sharing modes for you to choose from. üòÑ\nKeep in mind that any collected data is string-based and as concise as possible, this is, no training data, model parameter, or input array to your function or model will leave your computer at any time in terms of telemetry.\nAll of the data is totally anonymised, and is used to inform about Ivy‚Äôs usage, helping us prioritize the development of features and the improvement of the most used functions across all the versions of all the frameworks when it comes to compilation and transpilation.\nIvy will be a much better framework if it‚Äôs possible to prioritize adding new functions and improving existing ones based on their actual usage in the community, rather than leaving this all to guess work and potentially focusing our efforts on functions people don‚Äôt actually want or need.\nMore specifically, by sharing your data, this means more time will be spent on improving the functions, frameworks, and computation graphs that matter most for your projects.\nIf you use the premium features with an account, this data is stored in a database with the key being your account id. If you do not create an Ivy account, the data is stored in a database with the key being a securely hashed version of the IP address from where the call was made.\n\n\nThis section outlines the different modes available to all users, as well as the data that is collected for each one when calling ivy.compile, ivy.transpile, or ivy.unify.\n\nstealth\n\nNo data at all. üòÑ\nThis mode is limited to users with the enterprise license only.\n\napi-calls\n\nIvy function signature and its timestamp.\nAs an example, the message produced by this function call would be:\ncomp_fn = ivy.compile(fn, to=‚Äùtorch‚Äù, include_generators=True)\n\n{\n    \"function\": ivy.compile,\n    \"timestamp\": 108586,\n    \"flags\": {\"to\": \"torch\", \"include_generators\": \"True\"}\n}\nThis is helpful to understand the typical usage of Ivy, making it possible to focus the development on the more widely used features and use cases of Ivy.\n\nfunctional-api\n\nIvy function signature, timestamp, and the set of used functions from the corresponding functional API, without their frequencies.\nA sample message in this case would be similar to:\ncomp_fn = ivy.compile(fn, to=‚Äùtorch‚Äù, include_generators=True)\n\n{\n    \"function\": ivy.compile,\n    \"timestamp\": 108586,\n    \"flags\": {\"to\": \"torch\", \"include_generators\": \"True\"},\n    \"functions\": [\"torch.add\", \"torch.matmul\"]\n}\nAs mentioned above, this helps prioritize the addition of new functions and fixing of existing ones based on actual user usage of them, rather than relying on guess work and potentially focusing our efforts on functions that may not be wanted or needed by the users.\n\nfunctional-api-frequency\n\nIvy function signature, timestamp, and the set of used functions from the corresponding functional API along the number of calls to each function.\nA sample message if this mode is selected would be:\ncomp_fn = ivy.compile(fn, to=‚Äùtorch‚Äù, include_generators=True)\n\n{\n    \"function\": ivy.compile,\n    \"timestamp\": 108586,\n    \"flags\": {\"to\": \"torch\", \"include_generators\": \"True\"},\n    \"functions\": [[\"torch.add\", 2], [\"torch.matmul\", 1]]\n}\nSimilar to the previous mode, this helps even more to prioritize certain functions that need to be included, fixed, or optimized based on their actual usage. The usage frequencies give another very helpful data point to be even more accurate with function prioritization, as it‚Äôs now possible to focus on the functions depending on how commonly used they are.\nNOTE: Users with the early pilot access should have this mode turned on at the minimum. This helps in informing the team about how Ivy is being used and where it can be improved. Thus, we ask for more usage data in order to improve our product at a faster pace.\n\ngraph\n\nIvy function signature, timestamp and a text-based representation of the computation graph. This mode is set by default on pip install ivy.\nIf this mode is selected, telemetry messages will be similar to:\ncomp_fn = ivy.compile(fn, to=‚Äùtorch‚Äù, include_generators=True)\n{\n    \"function\": ivy.compile,\n    \"timestamp\": 108586,\n    \"flags\": {\"to\": \"torch\", \"include_generators\": \"True\"},\n    \"graph\": \"&lt;graph_representation&gt;\"\n}\nwhere &lt;graph_representation&gt; would be a string containing:\np708217 = args[0]\np862415 = args[1]\np817145 = torch.add(p708217, p862415)\np913484 = torch.add(p708217, p817145)\np868273 = torch.matmul(p913484, p817145)\nreturn p868273\nIn this case, telemetry helps not only with the function-level prioritization, but also with sub-function fixes and optimizations in Ivy‚Äôs functional API and Ivy‚Äôs frontends, as it‚Äôs now possible to distinguish which parameters or flags are used more often by users of the compiler and the transpiler.\nFurthermore, having an anonymized, minimal version of the computational graph allows us to recreate and explore any error that arises during compilation or transpilation, which once again enables the prioritization of bug fixes and features based on real-world usage.\nBelow, you can find a summary of the modes and their corresponding data levels:\n\n\n\n\n\n\n\n\n\n\n\n\nstealth\napi-calls\nfunctional-api\nfunctional-api-frequency\ngraph\n\n\n\n\nIvy signature\n-\nx\nx\nx\nx\n\n\nTime stamp\n-\nx\nx\nx\nx\n\n\nFunctions\n-\n-\nx\nx\nx\n\n\nFrequency\n-\n-\n-\nx\nx\n\n\nGraph repr.\n-\n-\n-\n-\nx\n\n\n\n\n\n\nBy default, the telemetry mode is graph. To change this setting, you should modify the config.json file that you can find inside of your .ivy directory. More specifically, you will have to change the data_level field. For example, if you want to limit the telemetry to avoid sending the computational graph, you can modify config.json so that it looks like this:\n{\n    \"data_level\": \"functional-api-frequency\"\n}"
  },
  {
    "objectID": "telemetry/index.html#telemetry-policy",
    "href": "telemetry/index.html#telemetry-policy",
    "title": "Ivy",
    "section": "",
    "text": "We want to give Ivy‚Äôs users as much flexibility as possible when it comes to data collection. Therefore, there are five different data sharing modes for you to choose from. üòÑ\nKeep in mind that any collected data is string-based and as concise as possible, this is, no training data, model parameter, or input array to your function or model will leave your computer at any time in terms of telemetry.\nAll of the data is totally anonymised, and is used to inform about Ivy‚Äôs usage, helping us prioritize the development of features and the improvement of the most used functions across all the versions of all the frameworks when it comes to compilation and transpilation.\nIvy will be a much better framework if it‚Äôs possible to prioritize adding new functions and improving existing ones based on their actual usage in the community, rather than leaving this all to guess work and potentially focusing our efforts on functions people don‚Äôt actually want or need.\nMore specifically, by sharing your data, this means more time will be spent on improving the functions, frameworks, and computation graphs that matter most for your projects.\nIf you use the premium features with an account, this data is stored in a database with the key being your account id. If you do not create an Ivy account, the data is stored in a database with the key being a securely hashed version of the IP address from where the call was made.\n\n\nThis section outlines the different modes available to all users, as well as the data that is collected for each one when calling ivy.compile, ivy.transpile, or ivy.unify.\n\nstealth\n\nNo data at all. üòÑ\nThis mode is limited to users with the enterprise license only.\n\napi-calls\n\nIvy function signature and its timestamp.\nAs an example, the message produced by this function call would be:\ncomp_fn = ivy.compile(fn, to=‚Äùtorch‚Äù, include_generators=True)\n\n{\n    \"function\": ivy.compile,\n    \"timestamp\": 108586,\n    \"flags\": {\"to\": \"torch\", \"include_generators\": \"True\"}\n}\nThis is helpful to understand the typical usage of Ivy, making it possible to focus the development on the more widely used features and use cases of Ivy.\n\nfunctional-api\n\nIvy function signature, timestamp, and the set of used functions from the corresponding functional API, without their frequencies.\nA sample message in this case would be similar to:\ncomp_fn = ivy.compile(fn, to=‚Äùtorch‚Äù, include_generators=True)\n\n{\n    \"function\": ivy.compile,\n    \"timestamp\": 108586,\n    \"flags\": {\"to\": \"torch\", \"include_generators\": \"True\"},\n    \"functions\": [\"torch.add\", \"torch.matmul\"]\n}\nAs mentioned above, this helps prioritize the addition of new functions and fixing of existing ones based on actual user usage of them, rather than relying on guess work and potentially focusing our efforts on functions that may not be wanted or needed by the users.\n\nfunctional-api-frequency\n\nIvy function signature, timestamp, and the set of used functions from the corresponding functional API along the number of calls to each function.\nA sample message if this mode is selected would be:\ncomp_fn = ivy.compile(fn, to=‚Äùtorch‚Äù, include_generators=True)\n\n{\n    \"function\": ivy.compile,\n    \"timestamp\": 108586,\n    \"flags\": {\"to\": \"torch\", \"include_generators\": \"True\"},\n    \"functions\": [[\"torch.add\", 2], [\"torch.matmul\", 1]]\n}\nSimilar to the previous mode, this helps even more to prioritize certain functions that need to be included, fixed, or optimized based on their actual usage. The usage frequencies give another very helpful data point to be even more accurate with function prioritization, as it‚Äôs now possible to focus on the functions depending on how commonly used they are.\nNOTE: Users with the early pilot access should have this mode turned on at the minimum. This helps in informing the team about how Ivy is being used and where it can be improved. Thus, we ask for more usage data in order to improve our product at a faster pace.\n\ngraph\n\nIvy function signature, timestamp and a text-based representation of the computation graph. This mode is set by default on pip install ivy.\nIf this mode is selected, telemetry messages will be similar to:\ncomp_fn = ivy.compile(fn, to=‚Äùtorch‚Äù, include_generators=True)\n{\n    \"function\": ivy.compile,\n    \"timestamp\": 108586,\n    \"flags\": {\"to\": \"torch\", \"include_generators\": \"True\"},\n    \"graph\": \"&lt;graph_representation&gt;\"\n}\nwhere &lt;graph_representation&gt; would be a string containing:\np708217 = args[0]\np862415 = args[1]\np817145 = torch.add(p708217, p862415)\np913484 = torch.add(p708217, p817145)\np868273 = torch.matmul(p913484, p817145)\nreturn p868273\nIn this case, telemetry helps not only with the function-level prioritization, but also with sub-function fixes and optimizations in Ivy‚Äôs functional API and Ivy‚Äôs frontends, as it‚Äôs now possible to distinguish which parameters or flags are used more often by users of the compiler and the transpiler.\nFurthermore, having an anonymized, minimal version of the computational graph allows us to recreate and explore any error that arises during compilation or transpilation, which once again enables the prioritization of bug fixes and features based on real-world usage.\nBelow, you can find a summary of the modes and their corresponding data levels:\n\n\n\n\n\n\n\n\n\n\n\n\nstealth\napi-calls\nfunctional-api\nfunctional-api-frequency\ngraph\n\n\n\n\nIvy signature\n-\nx\nx\nx\nx\n\n\nTime stamp\n-\nx\nx\nx\nx\n\n\nFunctions\n-\n-\nx\nx\nx\n\n\nFrequency\n-\n-\n-\nx\nx\n\n\nGraph repr.\n-\n-\n-\n-\nx\n\n\n\n\n\n\nBy default, the telemetry mode is graph. To change this setting, you should modify the config.json file that you can find inside of your .ivy directory. More specifically, you will have to change the data_level field. For example, if you want to limit the telemetry to avoid sending the computational graph, you can modify config.json so that it looks like this:\n{\n    \"data_level\": \"functional-api-frequency\"\n}"
  }
]